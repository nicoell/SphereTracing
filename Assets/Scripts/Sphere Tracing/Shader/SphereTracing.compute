#pragma kernel CSMainHigh
#pragma kernel CSMainMid
#pragma kernel CSMainLow

#define CSMainHighThreadsX 32
#define CSMainHighThreadsY 20
#define CSMainHighThreadsZ 1

#define CSMainMidThreadsX 16
#define CSMainMidThreadsY 16
#define CSMainMidThreadsZ 1

#define CSMainLowThreadsX 8
#define CSMainLowThreadsY 8
#define CSMainLowThreadsZ 1


#include "ImplicitBasics.cginc"         //Contains the basics like primitives or operations.
#include "StructDefinitions.cginc"      //Contains definitons of structs.     
#include "WorldLogic.cginc"             //Contains the map of the world and related stuff unique to the world.

/*
 * Variables set from CPU side, like uniforms
 */
RWTexture2D<float4> SphereTracingTexture;   //Target Render Texture with Read Write Access


float4 CameraFrustumEdgeVectors[4];         //Array of the cameras frustum edge vectors, clockwise beginning in the topleft.
float4x4 CameraInverseViewMatrix;       
float3 CameraPos;   
float2 Resolution;                          //Width and Height of RenderTexture
float4 Time;                                //x: Time in s   y: x/20     z: deltaTime      w: 1/z

int SphereTracingSteps;


float3 CalculateNormal(in float3 pos)
{
	const float3 epsilon = float3(0.001, 0.0, 0.0);
	
	float gradientX = Map(pos + epsilon.xyy).x - Map(pos - epsilon.xyy).x;
	float gradientY = Map(pos + epsilon.yxy).x - Map(pos - epsilon.yxy).x;
	float gradientZ = Map(pos + epsilon.yyx).x - Map(pos - epsilon.yyy).x;
	
	float3 normal = float3(gradientX, gradientY, gradientZ);
	
	return normalize(normal);
}

/*
 *  RayMarch
 * 
 *  Performs Sphere Tracing along given Ray
 *      x: Total trace distance travelled along Ray (t * rayDir)
 *      y: Material ID of hit object (-1 if nothing hit)
 */
float2 RayMarch(in Ray r)
{
	const float TRACE_DISTANCE_MAX = 1000.0;
	float2 res = float2(1.0, -1.0); // result

    //Trace along ray with sphere tracing algorithm. 
	for(int i = 0; i < SphereTracingSteps; i++)
	{
		float epsilon = 0.00015 * res.x;
		float3 pointOnRay = r.Origin + res.x * r.Direction;
		float2 hit = Map(pointOnRay);
		
		//If we hit something or exceed the maximum trace distnace we stop immediately.
		if (hit.x < epsilon || res.x > TRACE_DISTANCE_MAX) break;
		
		res.x += hit.x;
		res.y = hit.y;
	}
	
	if (res.x > TRACE_DISTANCE_MAX)  res.y = -1.0;
	
	return res;
}

void Main(uint3 id)
{
    //UVs on Screen
	float2 uv = float2((id.x + 0.5) / Resolution.x, (id.y + 0.5) / Resolution.y);

	//Construct Ray
	Ray r;
	r.Origin = CameraPos;
	float4 rayDir = normalize(lerp(
	    lerp(CameraFrustumEdgeVectors[3], CameraFrustumEdgeVectors[2], uv.x),
	    lerp(CameraFrustumEdgeVectors[0], CameraFrustumEdgeVectors[1], uv.x),
	    uv.y));
	r.Direction = mul(CameraInverseViewMatrix, rayDir).xyz;
	
	float3 color = Background(r); //Evaluate Background
	float3 normal = float3(.0, .0, .0);
	
	float2 tm = RayMarch(r); //t: traceDistance, m: materialID
	float t = tm.x;
	float matID = tm.y;
	if (matID > 0.5)
	{
	    float3 pos = r.Origin + t * r.Direction;
	    normal = CalculateNormal(pos);
	    Material mat;
	    
	    EvaluateMaterial(matID, r, pos, normal, mat);
	    
	    color = Shading(t, r, pos, mat);
	} else 
	{
        //No material ID, we hit the background.
	}
	
	//Write Color to Texture
	SphereTracingTexture[uint2(id.xy)] = float4(color, 1.0);
}


[numthreads(CSMainHighThreadsX, CSMainHighThreadsY, CSMainHighThreadsZ)]
void CSMainHigh (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainMidThreadsX, CSMainMidThreadsY, CSMainMidThreadsZ)]
void CSMainMid (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainLowThreadsX, CSMainLowThreadsY, CSMainLowThreadsZ)]
void CSMainLow (uint3 id : SV_DispatchThreadID) { Main(id); }

