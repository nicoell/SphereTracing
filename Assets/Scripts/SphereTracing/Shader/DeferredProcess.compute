#pragma kernel CSMainHigh   DEFERRED_PROCESS
#pragma kernel CSMainMid    DEFERRED_PROCESS
#pragma kernel CSMainLow    DEFERRED_PROCESS

#define CSMainHighThreadsX 32
#define CSMainHighThreadsY 20
#define CSMainHighThreadsZ 1

#define CSMainMidThreadsX 16
#define CSMainMidThreadsY 16
#define CSMainMidThreadsZ 1

#define CSMainLowThreadsX 8
#define CSMainLowThreadsY 8
#define CSMainLowThreadsZ 1

#include "Inputs/DeferredProcessInputs.cginc"
#include "Inputs/DeferredRenderingInputs.cginc"
#include "Inputs/SharedInputs.cginc"
#include "Defines/Structs.cginc"

#include "DeferredLogic.cginc"

void Main(uint3 id)
{
    //Bicubic Upscaling
    //if (!ConsiderAmbientOcclusion(id.xy)) return;
    //uint2 s = uint2(AmbientOcclusionStep, 0);
    uint2 u = uint2(1, 0);

    //Texture Write Coordinates
    uint2 xy00 = AmbientOcclusionStep * id.xy;// - uint2(id.x % s.x, id.y % s.x);
    //uint2 xy01 = xy00 + s.yx;  uint2 xy10 = xy00 + s.xy;      uint2 xy11 = xy00 + s.xx;
    
    //Texture Read Coordinates
    uint2 rxy00 = id.xy;        uint2 rxy10 = rxy00 + u.xy;
    uint2 rxy01 = rxy00 + u.yx; uint2 rxy11 = rxy00 + u.xx;
    
    //Surface AOs
    AmbientOcclusion sao00;  AmbientOcclusion sao01;
    AmbientOcclusion sao10;  AmbientOcclusion sao11;
    //Represent AOs
    AmbientOcclusion rao00;  AmbientOcclusion rao01;
    AmbientOcclusion rao10;  AmbientOcclusion rao11;
    //Read AOs from downsampled Texture
    DecodeAmbientOcclusion(AmbientOcclusionTarget, rxy00, 0, sao00, rao00);
    DecodeAmbientOcclusion(AmbientOcclusionTarget, rxy01, 0, sao01, rao01);
    DecodeAmbientOcclusion(AmbientOcclusionTarget, rxy10, 0, sao10, rao10);
    DecodeAmbientOcclusion(AmbientOcclusionTarget, rxy11, 0, sao11, rao11);
    
    float2 fs = float2((float) AmbientOcclusionStep, (float) AmbientOcclusionStep);
    
    for(uint x = 0; x < AmbientOcclusionStep; x++){
        for(uint y = 0; y < AmbientOcclusionStep; y++){
            uint2 xy = uint2(x, y);
            //float2 t = float2((float) x / fs.x, (float) y / fs.y);
            //if (xy.x == 0 && xy.y == 0) continue;
            //float2 t = (float2) (xy) / (float) AmbientOcclusionStep;
            float2 t = (float2) (xy) / fs;
            t = smoothstep(float2(0, 0), float2(1,1), t);
            //Interpolate between downsampled AOs
            AmbientOcclusion saoL = LerpAO(LerpAO(sao00, sao10, t.x), LerpAO(sao01, sao11, t.x), t.y);
            AmbientOcclusion raoL = LerpAO(LerpAO(rao00, rao10, t.x), LerpAO(rao01, rao11, t.x), t.y);
            //Write interpolated Aos
            EncodeUnscaledAmbientOcclusion(AmbientOcclusionDeferred, xy00 + xy, 0, saoL, raoL);
            //EncodeUnscaledAmbientOcclusion(AmbientOcclusionDeferred, xy00 + xy, 0, sao00, rao00);
        }
    }
}

[numthreads(CSMainHighThreadsX, CSMainHighThreadsY, CSMainHighThreadsZ)]
void CSMainHigh (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainMidThreadsX, CSMainMidThreadsY, CSMainMidThreadsZ)]
void CSMainMid (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainLowThreadsX, CSMainLowThreadsY, CSMainLowThreadsZ)]
void CSMainLow (uint3 id : SV_DispatchThreadID) {  Main(id); }
