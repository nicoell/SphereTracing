#pragma kernel DeferredH DEF_RW ST_R AO_R HIGH
#pragma kernel DeferredM DEF_RW ST_R AO_R MID
#pragma kernel DeferredL DEF_RW ST_R AO_R LOW

#ifdef HIGH
    #define ThreadsX 32
    #define ThreadsY 20
    #define ThreadsZ 1
#elif MID
    #define ThreadsX 16
    #define ThreadsY 16
    #define ThreadsZ 1
#elif LOW
    #define ThreadsX 8
    #define ThreadsY 8
    #define ThreadsZ 1
#endif

#include "Inputs/DeferredFinalizeInputs.cginc"
#include "Inputs/DeferredRenderingInputs.cginc"
#include "Inputs/SharedInputs.cginc"
#include "Defines/Structs.cginc"

#include "DeferredLogic.cginc"

float3 Background(in Ray r);

float3 Shading(SphereTracingData surface, AmbientOcclusion ao)
{
    float3 color = float3(.0, .0, .0);
    
    //Skip shading if alpha is too low
    if (surface.Alpha <= 0.001) return color;
    
    float3 ambientColor = float3(.1, .1, .1);
	float3 diffuseColor = float3(.0, .0, .0);
	float3 specularColor = float3(.0, .0, .0);
	
	float3 bentNormal = EnableAmbientOcclusion ? ao.BentNormal : surface.Normal;
	float specularOcclusion = EnableAmbientOcclusion ? ao.SpecularOcclusion : 1;
	float diffuseOcclusion = EnableAmbientOcclusion ? pow(length(bentNormal), OcclusionExponent) : 1;
	
	int matId = (int) surface.MaterialId;
	
	if (sign(matId) >= 0){
        StMaterial mat = MaterialBuffer[matId];
        
        if (EnableAmbientOcclusion && EnableGlobalIllumination){
            Ray aoRay;
            aoRay.Origin = float3(0,0,0);
            aoRay.Direction = bentNormal;
            ambientColor = diffuseOcclusion * Background(aoRay);
        }
        
        for(int i = 0; i < LightCount; i++)
        {
            StLight light = LightBuffer[i];
            if (light.LightType < 0) break;
            
            //Compute BlinnPhong Lightning
            float3 lightDir;
            float3 lightColor;
            float3 lightPower;
            float attenuation = 1.0;
    
            if (light.LightType == 0)               // Point Light
            {
                lightDir = light.LightData2.xyz - surface.Position;
                lightPower = light.LightData.w;
                attenuation = lightPower / length(lightDir);
                lightDir = normalize(lightDir);
                lightColor = light.LightData.xyz;
            } else if (light.LightType == 1)        // Directional Light
            {
                lightDir = light.LightData2.xyz;
                lightColor = light.LightData.xyz;
                lightPower = light.LightData.w;
            }
            
            float lambertian = max(dot(surface.Normal, lightDir), 0.0);
            float specular = 0.0;
            
            //if (lambertian > 0) {
                float3 halfDir = normalize(lightDir + (-CameraDir));
                float specularAngle = max(dot(surface.Normal, halfDir), 0.0);
                specular = pow(specularAngle, mat.Shininess);
            //} 
            
            diffuseColor += mat.DiffuseColor * lambertian * lightColor * attenuation;
            specularColor += mat.SpecularColor * specular * lightColor * attenuation;
        }
        
        diffuseColor *= diffuseOcclusion;
        specularColor *= specularOcclusion;
        
        //Add up color
        color = ambientColor + diffuseColor + specularColor;
	} else {
	    Ray r;
	    r.Origin = float3(0,0,0);
	    r.Direction = surface.RayDirection;
	    color = Background(r);
	    
	}
	//Gamma correct colors
 
	return float3(color);
}

void Main(uint3 id)
{
    float2 uv = float2((id.x + 0.5) / Resolution.x, (id.y + 0.5) / Resolution.y);
    
    SphereTracingData Surface;
	SphereTracingData Represent;
	AmbientOcclusion SurfaceAo;
	AmbientOcclusion RepresentAo;
    
    DecodeSphereTracingData(id.xy, 0, Surface);
    DecodeSphereTracingData(id.xy, 1, Represent);
    if (EnableAmbientOcclusion) {
        DecodeAmbientOcclusionBilateral(uv, 0, 0, SurfaceAo);
        DecodeAmbientOcclusionBilateral(uv, 1, 0, RepresentAo);
    } else {
        //... Need to fill struct maybe
    }
    
    float3 surfaceColor = (Surface.Alpha - Represent.Alpha) * Shading(Surface, SurfaceAo);
    float3 representColor = Represent.Alpha * Shading(Represent, RepresentAo);
    
    float3 outputColor = surfaceColor + representColor;
    outputColor = pow( max(outputColor,0.0), GammaCorrection);
    
    if (IsFirstPass) DeferredOutputTexture[uint2(id.xy)] = ClearColor;
    
    
    if (RenderOutput == 0) DeferredOutputTexture[uint2(id.xy)] =      DeferredOutputTexture[uint2(id.xy)] + float4(outputColor, 1);
    else if (RenderOutput == 1) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4(surfaceColor, 1);
    else if (RenderOutput == 2) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4(representColor, 1);
    
    //TODO: Probably need to rethink which of these values should be summed up in debug view and which not.
    else if (RenderOutput == 3) DeferredOutputTexture[uint2(id.xy)] = float4(Surface.Position / ClippingPlanes.y, 1);
    else if (RenderOutput == 4) DeferredOutputTexture[uint2(id.xy)] = float4((float3) Surface.MaterialId / MaterialCount, 1);
    else if (RenderOutput == 5) DeferredOutputTexture[uint2(id.xy)] = float4(Surface.RayDirection, 1);
    else if (RenderOutput == 6) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4((float3) Surface.TraceDistance / ClippingPlanes.y, 1);
    else if (RenderOutput == 7) DeferredOutputTexture[uint2(id.xy)] = float4(Surface.Normal, 1);
    else if (RenderOutput == 8) DeferredOutputTexture[uint2(id.xy)] = float4((float3) Surface.Alpha, 1);
    else if (RenderOutput == 9) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4(SurfaceAo.BentNormal, 1);
    else if (RenderOutput == 10) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4((float3) length(SurfaceAo.BentNormal), 1);
    else if (RenderOutput == 11) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4((float3) SurfaceAo.SpecularOcclusion, 1);
    
    else if (RenderOutput == 12) DeferredOutputTexture[uint2(id.xy)] = float4(Represent.Position / ClippingPlanes.y, 1);
    else if (RenderOutput == 13) DeferredOutputTexture[uint2(id.xy)] = float4((float3) Represent.MaterialId / MaterialCount, 1);
    else if (RenderOutput == 14) DeferredOutputTexture[uint2(id.xy)] = float4(Represent.RayDirection, 1);
    else if (RenderOutput == 15) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4((float3) Represent.TraceDistance/ ClippingPlanes.y, 1);
    else if (RenderOutput == 16) DeferredOutputTexture[uint2(id.xy)] = float4(Represent.Normal, 1);
    else if (RenderOutput == 17) DeferredOutputTexture[uint2(id.xy)] = float4((float3) Represent.Alpha, 1);
    else if (RenderOutput == 18) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4(RepresentAo.BentNormal, 1);
    else if (RenderOutput == 19) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4((float3) length(RepresentAo.BentNormal), 1);
    else if (RenderOutput == 20) DeferredOutputTexture[uint2(id.xy)] = DeferredOutputTexture[uint2(id.xy)] + float4((float3) RepresentAo.SpecularOcclusion, 1);
    
}

[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void DeferredH (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void DeferredM (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void DeferredL (uint3 id : SV_DispatchThreadID) { Main(id); }


/*
 *  BACKGROUND
 * 
 *  Background/Sky related functions from here on. Need more comments
 */
float3 totalMie(in float T)
{
	float3 MieConst = float3(1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );
	float c = (0.2*T) * 10E-18;
	return 0.434 * c * MieConst;
}

float sunIntensity(in float zenithAngleCos )
{   
	float e = 2.71828182845904523536028747135266249775724709369995957;
	float EE = 1000.0;
	float cutoffAngle = 1.6110731556870734;
	float steepness = 1.5;
	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos)) / steepness ) ) );
}

float hgPhase(in float cosTheta,in float g)
{
	float ONE_OVER_FOURPI = 0.07957747154594767;
	float g2 = pow( g, 2.0);
	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5);
	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
}

float rayleighPhase(in float cosTheta ) 
{
	float THREE_OVER_SIXTEENPI = 0.05968310365946075;
	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
}

float3 Uncharted2Tonemap(in float3 x)
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;
}

float3 Background(in Ray r)
{       
	
	float3 sunPosition = float3( 4000.0, 150.0, 7000.0 );
	float3 vSunDirection = normalize( sunPosition );

	float3 up = float3(0.0, 1.0, 0.0);

	float vSunE = sunIntensity( dot( vSunDirection, up ));
	float vSunfade = 1.0 - clamp( 1.0 - exp((sunPosition.y / 450000.0 )), 0.0, 1.0);

	float rayleigh = 2.0;
	float3 totalRayleigh = float3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );
	float rayleighCoefficient = rayleigh - (1.0 * (1.0 - vSunfade ));
	float3 vBetaR = totalRayleigh * rayleighCoefficient;

	float turbidity = 10.0;
	float mieCoefficient = 0.005;
	float vBetaM = totalMie( turbidity ) * mieCoefficient;

	float pi = 3.141592653589793238462643383279502884197169;
	float rayleighZenithLength = 8.4E3;
	float mieZenithLength = 1.25E3;
	float zenithAngle = acos(max(0.0, dot( up, normalize(r.Direction) ) ) );
	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253) );
	float sR = rayleighZenithLength * inverse;
	float sM = mieZenithLength * inverse;

	float3 Fex = exp( -( vBetaR * sR + vBetaM * sM) );

	float cosTheta = dot( normalize(r.Direction), vSunDirection );
	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5);
	float3 betaRTheta = vBetaR * rPhase;

	float mieDirectionalG = 0.8;
	float mPhase = hgPhase( cosTheta, mieDirectionalG);
	float3 betaMTheta = vBetaM * mPhase;

	float3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), float3( 1.5 , 1.5, 1.5) );
	Lin *= lerp( float3( 1.0,1.0,1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, float3( 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

	float theta = acos(r.Direction.y);
	float phi = atan2(r.Direction.z, r.Direction.x);
	float2 uv = float2(phi, theta);
	float3 L0 = float3(0.1,0.1,0.1) * Fex;

	float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;
	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta);
	L0 += ( vSunE * 19000.0 * Fex) * sundisk;

	float luminance = 1.0;
	float whiteScale = 1.0748724675633854;
	float3 texColor = (Lin + L0) * 0.04 + float3(0.0, 0.0003, 0.00075);
	float3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );
	float3 color = curr * whiteScale;

	float retc =  1.0 / ( 1.2 + ( 1.2 * vSunfade ) );
	float3 retColor = pow( color, float3(retc, retc, retc));

	//return r.Direction;
	return retColor;
}
