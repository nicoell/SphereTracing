#pragma kernel CSMainHigh   DEFERRED_FINALIZE
#pragma kernel CSMainMid    DEFERRED_FINALIZE
#pragma kernel CSMainLow    DEFERRED_FINALIZE

#define CSMainHighThreadsX 32
#define CSMainHighThreadsY 20
#define CSMainHighThreadsZ 1

#define CSMainMidThreadsX 16
#define CSMainMidThreadsY 16
#define CSMainMidThreadsZ 1

#define CSMainLowThreadsX 8
#define CSMainLowThreadsY 8
#define CSMainLowThreadsZ 1

#include "Inputs/DeferredRenderingInputs.cginc"
#include "Inputs/SharedInputs.cginc"
#include "Defines/Structs.cginc"

#include "DeferredLogic.cginc"

void Main(uint3 id)
{
    float2 uv = float2((id.x + 0.5) / Resolution.x, (id.y + 0.5) / Resolution.y);
    
    StUnion stUnion;
    DecodeSurfaceData(SurfaceDataDeferred, id.xy, 0, stUnion.Surface, stUnion.Represent);
    DecodeAmbientOcclusion(AmbientOcclusionDeferred, id.xy, 0, stUnion.SurfaceAo, stUnion.RepresentAo);
    DecodeDepth(DepthDeferred, id.xy, 0, stUnion.SurfaceDepth, stUnion.RepresentDepth);
    
    DeferredOutput[uint2(id.xy)] = float4(stUnion.Surface.Normal + stUnion.Represent.Alpha * stUnion.Represent.Normal, 1);
    /*if (stUnion.Surface.MaterialId == -1) DeferredOutput[uint2(id.xy)] = float4(1,1,1, 1);
    if (stUnion.Surface.MaterialId == 0) DeferredOutput[uint2(id.xy)] = float4(1,0,0, 1);
    if (stUnion.Surface.MaterialId == 1) DeferredOutput[uint2(id.xy)] = float4(0,1,0, 1);
    if (stUnion.Surface.MaterialId == 2) DeferredOutput[uint2(id.xy)] = float4(0,0,1, 1);
    if (stUnion.Surface.MaterialId == 3) DeferredOutput[uint2(id.xy)] = float4(0,1,1, 1);*/
    /*
    float3 ambientColor = float3(.1, .1, .1);
	float3 diffuseColor = float3(.0, .0, .0);
	float3 specularColor = float3(.0, .0, .0);
	float3 bentNormal = hit.Normal;
	float specularOcclusion = 1;
	float diffuseOcclusion = 1;
	
	if (EnableAmbientOcclusion) { 
		ComputeAO(hit, r, bentNormal, diffuseOcclusion, specularOcclusion);
		bentNormal = lerp(hit.Normal, bentNormal, BentNormalFactor);
		Ray aoRay;
		aoRay.Origin = r.Origin;
		aoRay.Direction = bentNormal;
		if (EnableGlobalIllumination) ambientColor = diffuseOcclusion * Background(aoRay);
	}

	for(int i = 0; i < LightCount; i++)
	{
	    StLight light = LightBuffer[i];
		if (light.LightType < 0) break;
		
		//Compute BlinnPhong Lightning
		float3 lightDir;
		float3 lightColor;
		float3 lightPower;
		float attenuation = 1.0;

		if (light.LightType == 0)               // Point Light
		{
			lightDir = light.LightData2.xyz - hit.Position;
			lightPower = light.LightData.w;
			attenuation = lightPower / length(lightDir);
			lightDir = normalize(lightDir);
			lightColor = light.LightData.xyz;
		} else if (light.LightType == 1)        // Directional Light
		{
			lightDir = light.LightData2.xyz;
			lightColor = light.LightData.xyz;
			lightPower = light.LightData.w;
		}
		
		float lambertian = max(dot(hit.Normal, lightDir), 0.0);
		float specular = 0.0;
		
		if (lambertian > 0) {
			float3 halfDir = normalize(lightDir + (-CameraDir));
			float specularAngle = max(dot(hit.Normal, halfDir), 0.0);
			specular = pow(specularAngle, hit.Material.Shininess);
		} 
		
		diffuseColor += hit.Material.DiffuseColor * lambertian * lightColor * attenuation;
		specularColor += hit.Material.SpecularColor * specular * lightColor * attenuation;
	}
	
	diffuseColor *= diffuseOcclusion;
	specularColor *= specularOcclusion;
	
	//Add up color
	float3 color = ambientColor + diffuseColor + specularColor;
	
	//Gamma correct colors
	color = pow( max(color,0.0), GammaCorrection);
 
	return color;*/
}

[numthreads(CSMainHighThreadsX, CSMainHighThreadsY, CSMainHighThreadsZ)]
void CSMainHigh (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainMidThreadsX, CSMainMidThreadsY, CSMainMidThreadsZ)]
void CSMainMid (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainLowThreadsX, CSMainLowThreadsY, CSMainLowThreadsZ)]
void CSMainLow (uint3 id : SV_DispatchThreadID) {  Main(id); }
