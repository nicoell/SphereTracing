#pragma kernel SphereTracingFPassH  ST_RW    F_PASS   HIGH
#pragma kernel SphereTracingFPassM  ST_RW    F_PASS   MID
#pragma kernel SphereTracingFPassL  ST_RW    F_PASS   LOW

#pragma kernel SphereTracingKPassH  ST_RW    K_PASS   HIGH
#pragma kernel SphereTracingKPassM  ST_RW    K_PASS   MID
#pragma kernel SphereTracingKPassL  ST_RW    K_PASS   LOW

#pragma kernel AmbientOcclusionH    ST_R    AO_RW    AO       HIGH
#pragma kernel AmbientOcclusionM    ST_R    AO_RW    AO       MID
#pragma kernel AmbientOcclusionL    ST_R    AO_RW    AO       LOW

#ifdef HIGH
    #define ThreadsX 32
    #define ThreadsY 20
    #define ThreadsZ 1
#elif MID
    #define ThreadsX 16
    #define ThreadsY 16
    #define ThreadsZ 1
#elif LOW
    #define ThreadsX 8
    #define ThreadsY 8
    #define ThreadsZ 1
#endif

#include "Defines/SharedConstants.cginc"
#include "Defines/Structs.cginc"
#include "Inputs/SharedInputs.cginc"
#include "Inputs/DeferredRenderingInputs.cginc"
#include "Inputs/SphereTracingInputs.cginc"
#include "Utils/ImplicitBasics.cginc" 
#include "WorldLogic.cginc"
#include "DeferredLogic.cginc"

#ifndef AO

float3 CalculateNormal(in float3 pos)
{
	const float3 epsilon = float3(0.01, 0.0, 0.0);
	
	float gradientX = Map(pos + epsilon.xyy).x - Map(pos - epsilon.xyy).x;
	float gradientY = Map(pos + epsilon.yxy).x - Map(pos - epsilon.yxy).x;
	float gradientZ = Map(pos + epsilon.yyx).x - Map(pos - epsilon.yyy).x;
	
	float3 normal = float3(gradientX, gradientY, gradientZ);
	
	return normalize(normal);
}

/*
 *  RayMarch
 * 
 *  Performs Sphere Tracing along given Ray
 *      x: Total trace distance travelled along Ray (t * rayDir)
 *      y: Material ID of hit object (-1 if nothing hit)
 */
void RayMarch(in Ray r, inout Hit surfaceHit, inout Hit representHit)
{
	//TODO: Don't use clippingplane as starting trace distance for reflections 
	surfaceHit.TraceDistance = ClippingPlanes.x;    //Start tracing at Near Plane
	surfaceHit.DistanceToWorld = ClippingPlanes.y;  
	surfaceHit.Alpha = 1;
	surfaceHit.MaterialId = -1; //No material is represented by material <= 0
	
	representHit.Position = float3(0,0,0);
    representHit.TraceDistance = ClippingPlanes.x; //Start tracing at Near Plane
	representHit.DistanceToWorld = 1000000;
	representHit.Alpha = 0;
	representHit.MaterialId = -1; //No material is represented by material <= 0
    
    //const float radiusP = 0.01; //radius of Pixel
    bool representFound = false;
    float t = ClippingPlanes.x;
    
    //float3 pointOnRay = r.Origin + t * r.Direction;
    float2 currentMap = Map(r.Origin + t * r.Direction); //start with negative distance and no material
    int i = 0;
    for(; i < SphereTracingSteps; i++)
	{   
	    float epsilon = 0.0015 * t;
	    //Test if we hit the surface
	    if (currentMap.x <= epsilon) {
	        //We hit the surface.
	        surfaceHit.DistanceToWorld = currentMap.x;
            surfaceHit.TraceDistance = t;
            surfaceHit.MaterialId = currentMap.y;
            surfaceHit.Position = r.Origin + surfaceHit.TraceDistance * r.Direction;
            break;
	    }
	    
	    //We didn't hit the surface yet so sample next sphere
	    float2 nextMap = Map(r.Origin + (t + currentMap.x) * r.Direction);

	    //Test if we are inside pixelRadius
	    if (currentMap.x < (t * RadiusPixel)) {
	        //We are inside the pixelRadius but we didn't hit a surface
	        //Test if the next sphere is bigger than the current one
	        if (nextMap.x > currentMap.x){
	            //Next sphere is bigger, meaning we move away from a surface
	            //Test if we have a represent by making sure it's the first time a sphere gets bigger next step
	            if (representFound == false){
	                //We found a represent
	                representFound = true;
	                //But we only want to save it, if it's the smallest represent in sphere radius
	                //and if we either did not found a represent yet or if we are still on same Material //this is Hacky and not garantued to produce nice results
	                if (currentMap.x < representHit.DistanceToWorld && (representHit.MaterialId == -1 || representHit.MaterialId == currentMap.y)){
	                    //We found a new smallest represent.
	                    representHit.DistanceToWorld = currentMap.x;
	                    representHit.TraceDistance = t;
	                    representHit.MaterialId = currentMap.y;
	                }
	            }
	        } else {
	            //Next sphere is not bigger, meaning we are getting closer to a surface
	            representFound = false;
	        }
	    }
	    
	    t += currentMap.x;
	    currentMap = nextMap;
	    
	    //Test if we exceeded far clippingplane
	    if (t > ClippingPlanes.y){
	        surfaceHit.MaterialId = -1;
	        break;
	    }
	}
	
	//Test if we found a represent by checking its MaterialId
	if (representHit.MaterialId >= 0) {
	    //Calculate how much the represent covers the pixel
	    representHit.Alpha = 1.0 - representHit.DistanceToWorld / (representHit.TraceDistance * RadiusPixel);
	    representHit.Position = r.Origin + representHit.TraceDistance * r.Direction;
	}
    
    //Test if we reached max SphereTracingSteps
    if (i == SphereTracingSteps) {
        //Use latest hit instead of background
        surfaceHit.TraceDistance = t;
		surfaceHit.MaterialId = currentMap.y;
		surfaceHit.DistanceToWorld = currentMap.x;
		surfaceHit.Position = r.Origin + surfaceHit.TraceDistance * r.Direction;
    }
}

void EvaluateHit(in uint2 xy, in Ray r, in Hit hit, inout SphereTracingData sd)
{
    sd.Position = hit.Position;
    sd.MaterialId = hit.MaterialId;
    sd.TraceDistance = hit.TraceDistance;
    if (sign(hit.MaterialId) >= 0)
    {
        sd.Normal = CalculateNormal(hit.Position);
        sd.RayDirection = r.Direction;
        sd.Alpha *= hit.Alpha;
    }
    //if the background is hit
    else
    {
        sd.Normal = (float3) 0;
        sd.RayDirection = r.Direction;
        sd.Alpha *= hit.Alpha;
    }
}

void Main(uint3 id)
{
    float2 uv = float2((id.x + 0.5) / Resolution.x, (id.y + 0.5) / Resolution.y);
    
    SphereTracingData Surface;
    SphereTracingData Represent;
    
    #ifdef F_PASS
        Surface.Alpha = 1.0;
        Represent.Alpha = 1.0;
        //Create Ray through current Pixel
        Ray r;
        r.uv = uv;
        r.Origin = CameraPos;
        float4 rayDir = (lerp(
            lerp(CameraFrustumEdgeVectors[3], CameraFrustumEdgeVectors[2], uv.x),
            lerp(CameraFrustumEdgeVectors[0], CameraFrustumEdgeVectors[1], uv.x),
            uv.y));
        r.Direction = (mul(CameraInverseViewMatrix, rayDir).xyz);
    #elif K_PASS
        //Read SphereTracingData from previuos pass
        DecodeSphereTracingData(id.xy, 0, Surface);
        DecodeSphereTracingData(id.xy, 1, Represent);
        //Do not calculate pass if neither surface nor represent alpha has an impact
        if (Surface.Alpha <= ALPHAEPSILON && Represent.Alpha <= ALPHAEPSILON) return;
        
        
        /*
         * TODO: Handle transparent materials
         *          Somehow need to exlude the transparent object in signed distance field
         *          Maybe use ScreenSpace Reflections in this case and only follow transparent ray
         *          Or use the represent Surface for transparency/reflection since it is only needed for edges
         */
        
        //Evaluate Material to calculate new Ray Direction
        StMaterial surfaceMat = MaterialBuffer[Surface.MaterialId];
        StMaterial representMat = MaterialBuffer[Represent.MaterialId];
        Surface.Alpha *= surfaceMat.ReflectiveF;
        Represent.Alpha *= representMat.ReflectiveF;
        //Test again if we need to calculate this pass
        if (Surface.Alpha <= ALPHAEPSILON && Represent.Alpha <= ALPHAEPSILON){
            //If not, we need to write the new alphas to texture before we stop
            EncodeSphereTracingData(id.xy, 0, Surface);
            EncodeSphereTracingData(id.xy, 1, Represent);
            return;
        }
        //We only follow one ray though, so we choose the one with greater visual impact
        Ray r;
        r.uv = uv;
        if (Surface.Alpha >= Represent.Alpha) {
            r.Origin = Surface.Position;
            //normalize(dir - 2 * normalize( dot(dir, normal) * normal))  
            r.Direction = reflect(normalize(Surface.RayDirection), Surface.Normal);
            //r.Direction = reflect(normalize(Surface.RayDirection), Surface.Normal);
        } else {
            r.Origin = Represent.Position;
            r.Direction = reflect(normalize(Represent.RayDirection), Represent.Normal);
            //r.Direction = reflect(normalize(Represent.RayDirection), Represent.Normal);
        }
    #endif

    Hit surfaceHit;
    Hit representHit;
    RayMarch(r, surfaceHit, representHit);
    EvaluateHit(id.xy, r, surfaceHit, Surface);
    EvaluateHit(id.xy, r, representHit, Represent);

    EncodeSphereTracingData(id.xy, 0, Surface);
    EncodeSphereTracingData(id.xy, 1, Represent);
}

[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void SphereTracingFPassH (uint3 id : SV_DispatchThreadID) { Main(id); }
[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void SphereTracingFPassM (uint3 id : SV_DispatchThreadID) { Main(id); }
[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void SphereTracingFPassL (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void SphereTracingKPassH (uint3 id : SV_DispatchThreadID) { Main(id); }
[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void SphereTracingKPassM (uint3 id : SV_DispatchThreadID) { Main(id); }
[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void SphereTracingKPassL (uint3 id : SV_DispatchThreadID) { Main(id); }
    
#endif


#ifdef AO

void CalcAO(uint3 id)
{
    float2 uv = float2((id.x + 0.5) / AoResolution.x, (id.y + 0.5) / AoResolution.y);
    
    SphereTracingData Surface;
	SphereTracingData Represent;
	AmbientOcclusion SurfaceAo;
	AmbientOcclusion RepresentAo;
    
    //Read SphereTracingData from surface and represent
    DecodeSphereTracingData(uv, 0.0, 0.0, Surface);
    DecodeSphereTracingData(uv, 1.0, 0.0, Represent);
    
    //Do not calculate ao if a surface' alpha doesn't have an impact
    if (Surface.Alpha > ALPHAEPSILON) {
        ComputeAO(uv, Surface.Position, Surface.RayDirection, Surface.Normal, 
            SurfaceAo.BentNormal, SurfaceAo.SpecularOcclusion);
    } else {
        SurfaceAo.BentNormal = (float3) 0;
        SurfaceAo.SpecularOcclusion = 0;
    }
    if (Represent.Alpha > ALPHAEPSILON) {
        ComputeAO(uv, Represent.Position, Represent.RayDirection, Represent.Normal, 
            RepresentAo.BentNormal, RepresentAo.SpecularOcclusion);
    } else {
        RepresentAo.BentNormal = (float3) 0;
        RepresentAo.SpecularOcclusion = 0;
    }
         
    EncodeAmbientOcclusion(id.xy, 0, SurfaceAo);
    EncodeAmbientOcclusion(id.xy, 1, RepresentAo);
}

[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void AmbientOcclusionH (uint3 id : SV_DispatchThreadID) { CalcAO(id); }
[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void AmbientOcclusionM (uint3 id : SV_DispatchThreadID) { CalcAO(id); }
[numthreads(ThreadsX, ThreadsY, ThreadsZ)]
void AmbientOcclusionL (uint3 id : SV_DispatchThreadID) { CalcAO(id); }

#endif