#pragma kernel CSMainHigh   DEFERRED_CREATE
#pragma kernel CSMainMid    DEFERRED_CREATE
#pragma kernel CSMainLow    DEFERRED_CREATE

#define CSMainHighThreadsX 32
#define CSMainHighThreadsY 20
#define CSMainHighThreadsZ 1

#define CSMainMidThreadsX 16
#define CSMainMidThreadsY 16
#define CSMainMidThreadsZ 1

#define CSMainLowThreadsX 8
#define CSMainLowThreadsY 8
#define CSMainLowThreadsZ 1

#include "Defines/SharedConstants.cginc"
#include "Defines/Structs.cginc"
#include "Inputs/SharedInputs.cginc"
#include "Inputs/DeferredRenderingInputs.cginc"
#include "Inputs/SphereTracingInputs.cginc"
#include "Utils/ImplicitBasics.cginc" 
#include "WorldLogic.cginc"
#include "DeferredLogic.cginc"

float3 CalculateNormal(in float3 pos)
{
	const float3 epsilon = float3(0.01, 0.0, 0.0);
	
	float gradientX = Map(pos + epsilon.xyy).x - Map(pos - epsilon.xyy).x;
	float gradientY = Map(pos + epsilon.yxy).x - Map(pos - epsilon.yxy).x;
	float gradientZ = Map(pos + epsilon.yyx).x - Map(pos - epsilon.yyy).x;
	
	float3 normal = float3(gradientX, gradientY, gradientZ);
	
	return normalize(normal);
}

/*
 *  RayMarch
 * 
 *  Performs Sphere Tracing along given Ray
 *      x: Total trace distance travelled along Ray (t * rayDir)
 *      y: Material ID of hit object (-1 if nothing hit)
 */
void RayMarch(in Ray r, inout Hit surfaceHit, inout Hit representHit)
{
	//TODO: Don't use clippingplane as starting trace distance for reflections 
	surfaceHit.TraceDistance = ClippingPlanes.x;    //Start tracing at Near Plane
	surfaceHit.DistanceToWorld = ClippingPlanes.y;  
	surfaceHit.Alpha = 1;
	surfaceHit.MaterialId = -1; //No material is represented by material <= 0
	
	representHit.Position = float3(0,0,0);
    representHit.TraceDistance = ClippingPlanes.x; //Start tracing at Near Plane
	representHit.DistanceToWorld = 1000000;
	representHit.Alpha = 0;
	representHit.MaterialId = -1; //No material is represented by material <= 0
    
    //const float radiusP = 0.01; //radius of Pixel
    bool representFound = false;
    float t = ClippingPlanes.x;
    
    //float3 pointOnRay = r.Origin + t * r.Direction;
    float2 currentMap = Map(r.Origin + t * r.Direction); //start with negative distance and no material
    int i = 0;
    for(; i < SphereTracingSteps; i++)
	{   
	    float epsilon = 0.0015 * t;
	    //Test if we hit the surface
	    if (currentMap.x <= epsilon) {
	        //We hit the surface.
	        surfaceHit.DistanceToWorld = currentMap.x;
            surfaceHit.TraceDistance = t;
            surfaceHit.MaterialId = currentMap.y;
            surfaceHit.Position = r.Origin + surfaceHit.TraceDistance * r.Direction;
            break;
	    }
	    
	    //We didn't hit the surface yet so sample next sphere
	    float2 nextMap = Map(r.Origin + (t + currentMap.x) * r.Direction);

	    //Test if we are inside pixelRadius
	    if (currentMap.x < (t * RadiusPixel)) {
	        //We are inside the pixelRadius but we didn't hit a surface
	        //Test if the next sphere is bigger than the current one
	        if (nextMap.x > currentMap.x){
	            //Next sphere is bigger, meaning we move away from a surface
	            //Test if we have a represent by making sure it's the first time a sphere gets bigger next step
	            if (representFound == false){
	                //We found a represent
	                representFound = true;
	                //But we only want to save it, if it's the smallest represent in sphere radius
	                //and if we either did not found a represent yet or if we are still on same Material //this is Hacky and not garantued to produce nice results
	                if (currentMap.x < representHit.DistanceToWorld && (representHit.MaterialId == -1 || representHit.MaterialId == currentMap.y)){
	                    //We found a new smallest represent.
	                    representHit.DistanceToWorld = currentMap.x;
	                    representHit.TraceDistance = t;
	                    representHit.MaterialId = currentMap.y;
	                }
	            }
	        } else {
	            //Next sphere is not bigger, meaning we are getting closer to a surface
	            representFound = false;
	        }
	    }
	    
	    t += currentMap.x;
	    currentMap = nextMap;
	    
	    //Test if we exceeded far clippingplane
	    if (t > ClippingPlanes.y){
	        surfaceHit.MaterialId = -1;
	        break;
	    }
	}
	
	//Test if we found a represent by checking its MaterialId
	if (representHit.MaterialId >= 0) {
	    //Calculate how much the represent covers the pixel
	    representHit.Alpha = 1.0 - representHit.DistanceToWorld / (representHit.TraceDistance * RadiusPixel);
	    representHit.Position = r.Origin + representHit.TraceDistance * r.Direction;
	}
    
    //Test if we reached max SphereTracingSteps
    if (i == SphereTracingSteps) {
        //Use latest hit instead of background
        surfaceHit.TraceDistance = t;
		surfaceHit.MaterialId = currentMap.y;
		surfaceHit.DistanceToWorld = currentMap.x;
		surfaceHit.Position = r.Origin + surfaceHit.TraceDistance * r.Direction;
    }
}

void EvaluateHit(in uint2 xy, in Ray r, in Hit hit, inout SurfaceData sd, inout AmbientOcclusion ao, inout float depth)
{
    sd.Position = hit.Position;
    sd.MaterialId = hit.MaterialId;
    sd.Alpha = hit.Alpha;
    depth = hit.TraceDistance;
    if (sign(hit.MaterialId) >= 0)
    {
        sd.Normal = CalculateNormal(hit.Position);
        if (ConsiderAmbientOcclusion(xy))
        { 
            if (EnableAmbientOcclusion)
            {
                ComputeAO(hit, r, sd.Normal, ao.BentNormal, ao.SpecularOcclusion);
                ao.BentNormal = lerp(sd.Normal, ao.BentNormal, BentNormalFactor);
            } else 
            {
                ao.BentNormal = (float3) 0;
                ao.SpecularOcclusion = 0;
            }
        }
    }
    //if the background is hit
    else
    {
        sd.Normal = r.Direction;
        if (ConsiderAmbientOcclusion(xy))
        {
            ao.BentNormal = (float3) 0;
            ao.SpecularOcclusion = 0;
        }
    }
}

void Main(uint3 id)
{
	//UVs on Screen
	float2 uv = float2((id.x + 0.5) / Resolution.x, (id.y + 0.5) / Resolution.y);

	//Struct containing everything needed for deferred rendering.
	StUnion stUnion;

	//Create Ray struct
	Ray r;
	r.Origin = CameraPos;
    float4 rayDir = (lerp(
        lerp(CameraFrustumEdgeVectors[3], CameraFrustumEdgeVectors[2], uv.x),
        lerp(CameraFrustumEdgeVectors[0], CameraFrustumEdgeVectors[1], uv.x),
        uv.y));
    r.Direction = (mul(CameraInverseViewMatrix, rayDir).xyz);
    r.uv = uv;

    Hit surfaceHit;
    Hit representHit;
    RayMarch(r, surfaceHit, representHit);
    EvaluateHit(id.xy, r, surfaceHit, stUnion.Surface, stUnion.SurfaceAo, stUnion.SurfaceDepth);
    EvaluateHit(id.xy, r, representHit, stUnion.Represent, stUnion.RepresentAo, stUnion.RepresentDepth);

    EncodeSurfaceData(SurfaceDataTarget, id.xy, 0, stUnion.Surface, stUnion.Represent);
    if (ConsiderAmbientOcclusion(id.xy))
        EncodeAmbientOcclusion(AmbientOcclusionTarget, id.xy, 0, stUnion.SurfaceAo, stUnion.RepresentAo);
    EncodeDepth(DepthTarget, id.xy, 0, stUnion.SurfaceDepth, stUnion.RepresentDepth);
}


[numthreads(CSMainHighThreadsX, CSMainHighThreadsY, CSMainHighThreadsZ)]
void CSMainHigh (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainMidThreadsX, CSMainMidThreadsY, CSMainMidThreadsZ)]
void CSMainMid (uint3 id : SV_DispatchThreadID) { Main(id); }

[numthreads(CSMainLowThreadsX, CSMainLowThreadsY, CSMainLowThreadsZ)]
void CSMainLow (uint3 id : SV_DispatchThreadID) {  Main(id); }

